"""
Core protocol/interface for UnitedDataframe mixins.

This protocol defines the exact interface that all mixins can rely on,
solving the "blind mixins" problem where mixins can't see what methods
and attributes are available.
"""

from typing import Generic, Dict, List, Any, Optional, TypeVar, Union, Sequence, Iterator, Tuple, Callable, overload, Iterable
from typing import TYPE_CHECKING
from pathlib import Path
import pandas as pd
import numpy as np
from readerwriterlock import rwlock
import h5py

# Runtime imports needed for TypeVar definitions and protocol class
from ..._dataframe.column_key import ColumnKey
from ..._dataframe.column_type import ARRAY_TYPE, ColumnType, SCALAR_TYPE, LOWLEVEL_TYPE, NUMERIC_SCALAR_TYPE
from ..internal_dataframe_name_formatter import InternalDataFrameColumnNameFormatter, SimpleInternalDataFrameNameFormatter
from ..._units_and_dimension.unit import Unit
from ..._units_and_dimension.dimension import Dimension
from ..grouping._groups import Groups
from ..._arrays.bool_array import BoolArray
from ..accessors._row_accessor import RowAccessor
from ..accessors._column_accessor import ColumnAccessor

if TYPE_CHECKING:
    from ..._dataframe.united_dataframe import UnitedDataframe

CK = TypeVar("CK", bound=Union[ColumnKey, str])
CK_CF = TypeVar("CK_CF", bound=Union[ColumnKey, str])
AT = TypeVar("AT", bound=ARRAY_TYPE)

T = TypeVar("T", bound="UnitedDataframe", covariant=True) # type: ignore[type-arg]

class UnitedDataframeProtocol(Generic[CK, T]):
    """
    Protocol for UnitedDataframe mixins.

    This protocol defines the exact interface that all mixins can rely on,
    solving the "blind mixins" problem where mixins can't see what methods
    and attributes are available.
    """

    ######### FIELDS #########

    # Core data structures - these tell IDE what attributes are available
    _internal_dataframe: pd.DataFrame
    _internal_dataframe_column_names: Dict[CK, str]
    _internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter
    
    # Derived data structures
    _column_keys: List[CK]
    _column_types: Dict[CK, ColumnType]
    _column_units: Dict[CK, Optional[Unit]]
    
    # State
    _read_only: bool
    
    # Thread safety
    _lock: rwlock.RWLockFairD
    _rlock: rwlock.RWLockFairD._aReader # type: ignore
    _wlock: rwlock.RWLockFairD._aWriter # type: ignore
    
    ######### METHODS #########

    ######### INTERNAL METHODS (NO LOCKS, NO READ-ONLY CHECK) #########

    @classmethod
    def _construct(cls, dataframe: pd.DataFrame, column_keys: List[CK], column_types: Dict[CK, ColumnType], column_units: Dict[CK, Optional[Unit]], internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter, read_only: bool = False, copy_dataframe: bool = False, rename_dataframe_columns: bool = False) -> "UnitedDataframe[CK]": ...

    # UnitMixin internal methods
    def _unit_has(self, column_key: CK) -> bool: ...
    def _unit_get(self, column_key: CK) -> Unit: ...

    # CoreMixin internal methods
    def _number_of_rows(self) -> int: ...
    def _number_of_columns(self) -> int: ...
    def _create_internal_dataframe_column_name(self, column_key: CK) -> str: ...
    def _get_internal_dataframe_column_name(self, column_key: CK) -> str: ...
    def _get_internal_dataframe_column_names(self, column_key: CK|Sequence[CK]|None = None) -> list[str]: ...
    def _is_compatible_with_column(self, column_key: CK, value: SCALAR_TYPE|ARRAY_TYPE) -> bool: ...
    
    # ColumnKeyMixin internal methods
    def _colkey_is_numeric(self, column_key: CK) -> bool: ...
    def _colkey_exists(self, column_key: CK) -> bool: ...
    def _colkey_get_of_type(self, *column_key_types: type[CK_CF]) -> list[CK_CF]: ...
    def _colkey_get_numeric(self) -> list[CK]: ...

    # CellOperationsMixin internal methods
    def _cell_get_value(self, row_index: int, column_key: CK) -> SCALAR_TYPE: ...
    def _cell_get_lowlevel_value(self, row_index: int, column_key: CK) -> LOWLEVEL_TYPE: ...
    def _cell_set_value(self, row_index: int, column_key: CK, value: SCALAR_TYPE): ...
    
    # GroupbyMixin internal methods
    def _groupby(self, by: Union[CK, List[CK]], sort: bool = True, dropna: bool = True) -> Groups[CK]: ...
    
    # MaskOperationsMixin internal methods
    def _mask_apply_to_dataframe(self, mask: BoolArray) -> "UnitedDataframe[CK]": ...   
    
    # RowOperationsMixin internal methods
    def _row_insert_empty(self, row_index: int, number_of_rows: int) -> None: ...
    def _row_set_values(self, row_index_or_slice: int | slice, values: dict[CK, list[Any]]) -> None: ...
    def _row_remove(self, row_index_start_inclusive: int, row_index_stop_exclusive: int) -> None: ...

    # RowAccessMixin internal methods
    def _row_get_as_dict(self, row_index: int, column_keys: Sequence[CK]|None = None) -> dict[CK, SCALAR_TYPE]: ...
    def _row_get_as_row_accessor(self, row_index: int, column_keys: Sequence[CK]|None = None) -> RowAccessor[CK]: ...
    
    # ColumnOperationsMixin internal methods
    def _column_add(self, column_key: CK, array: ARRAY_TYPE, column_type: ColumnType, unit: Unit) -> None: ...
    def _column_remove(self, column_key: CK) -> None: ...

    # ColumnAccessMixin internal methods
    def _column_get_as_pd_series(self, column_key: CK, slice: slice|None = None) -> pd.Series: ... # type: ignore[reportUnknownReturnType]
    def _column_get_as_numpy_array(self, column_key: CK, slice: slice|None = None) -> np.ndarray: ...
    def _column_get_as_array(self, column_key: CK, expected_column_type: type[ARRAY_TYPE], slice: slice|None = None) -> ARRAY_TYPE: ...
    def _columns_get_with_units(self) -> list[CK]: ...
    def _columns_get_without_units(self) -> list[CK]: ...
    def _column_get_as_column_accessor(self, column_key: CK, slice: slice|None = None) -> ColumnAccessor[CK]: ...

    # ConstructorMixin internal methods
    def _crop_dataframe(self, column_keys: Sequence[CK]|None = None, row_indices: slice|Sequence[int]|None = None) -> "UnitedDataframe[CK]": ...
    
    ######### CONSTRUCTOR METHODS #########

    def _create_with_replaced_dataframe(self, dataframe: pd.DataFrame) -> "UnitedDataframe[CK]": ...

    ######### STANDARD PRAXIS PYTHON METHODS #########

    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[CK]: ...
    def __next__(self) -> CK: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __contains__(self, key: Any) -> bool: ...
    def __repr__(self) -> str: ...
    def _repr_html_(self) -> str: ...
    @property
    def columns(self) -> pd.Index: ... # type: ignore[reportUnknownReturnType]
    @property
    def shape(self) -> Tuple[int, int]: ...
    @property
    def dtypes(self) -> pd.Series: ... # type: ignore[reportUnknownReturnType]
    @property
    def index(self) -> pd.Index: ... # type: ignore[reportUnknownReturnType]
    @property
    def values(self) -> np.ndarray: ...

    ######### USER METHODS #########

    # CoreMixin user methods
    def is_read_only(self) -> bool: ...
    def set_read_only(self, read_only: bool) -> None: ...
    def copy(self, deep: bool = True) -> "UnitedDataframe[CK]": ...
    def head(self, n: int = 5) -> "UnitedDataframe[CK]": ...
    def tail(self, n: int = 5) -> "UnitedDataframe[CK]": ...
    def get_internal_dataframe_column_name(self, column_key: CK) -> str: ...
    def get_internal_dataframe_column_names(self, column_key: CK|Sequence[CK]|None = None) -> list[str]: ...
    @property
    def internal_dataframe_column_name_formatter(self) -> InternalDataFrameColumnNameFormatter: ...
    def get_pandas_dataframe(self, deepcopy: bool = True, column_keys: dict[CK, str]|Iterable[CK] = {}) -> pd.DataFrame: ...

    # Itermixins

    # ColKeyMixin user methods
    @property
    def colkeys(self) -> list[CK]: ...
    def colkey_exists(self, column_key: CK) -> bool: ...
    def colkey_is_numeric(self, column_key: CK) -> bool: ...
    def colkey_get_numeric(self) -> list[CK]: ...

    # ColumnTypeMixin user methods
    @property
    def coltypes(self) -> dict[CK, ColumnType]: ...
    def coltype_get(self, column_key: CK) -> ColumnType: ...

    # UnitMixin user methods
    @property
    def units(self) -> dict[CK, Unit|None]: ...
    def unit_get_unit(self, column_key: CK) -> Unit: ...
    def unit_has_unit(self, column_key: CK) -> bool: ...
    def unit_change_unit(self, column_key: CK, unit: Unit) -> None: ...

    # DimensionMixin user methods
    @property
    def dimensions(self) -> dict[CK, Optional[Dimension]]: ...
    def dim_get_dimension(self, column_key: CK) -> Dimension: ...
    def dim_has_dimension(self, column_key: CK) -> bool: ...

    # ColumnOperationsMixin user methods
    def column_add(self, column_key: CK, array: ARRAY_TYPE, column_type: ColumnType, unit: Unit) -> None: ...
    def column_remove(self, column_key: CK) -> None: ...

    # ColumnAccessMixin user methods
    def column_get_as_pd_series(self, column_key: CK, slice: slice|None = None) -> pd.Series: ... # type: ignore[reportUnknownReturnType]
    def column_get_as_numpy_array(self, column_key: CK, slice: slice|None = None) -> np.ndarray: ...
    @overload
    def column_get_as_array(self, column_key: CK, expected_column_type: None = None, slice: slice|None = None) -> ARRAY_TYPE: ...
    @overload
    def column_get_as_array(self, column_key: CK, expected_column_type: type[AT], slice: slice|None = None) -> AT: ...
    def column_get_as_array(self, column_key: CK, expected_column_type: type[AT]|None = None, slice: slice|None = None) -> AT|ARRAY_TYPE: ...
    def column_get_with_units(self) -> list[CK]: ...
    def column_get_without_units(self) -> list[CK]: ...

    # ColumnStatisticsMixin user methods
    def column_get_min(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_max(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_mean(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_std(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_sum(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_product(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_variance(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_median(self, column_key: CK) -> NUMERIC_SCALAR_TYPE: ...
    def column_get_quantile(self, column_key: CK, quantile: float) -> NUMERIC_SCALAR_TYPE: ...
    def column_count_non_missing_values(self, column_key: CK) -> int: ...
    def column_count_missing_values(self, column_key: CK) -> int: ...

    # RowOperationsMixin user methods
    def row_add_values(self, values: dict[CK, list[Any] | Dict[CK, Any]]) -> None: ...
    def row_add_empty(self, number_of_rows: int) -> None: ...
    def row_insert_values(self, row_index: int|slice, values: dict[CK, list[Any] | Dict[CK, Any]]) -> None: ...
    def row_insert_empty(self, row_index: int|slice, number_of_rows: int) -> None: ...
    def row_set_values(self, row_index: int|slice, values: dict[CK, Any]) -> None: ...
    def row_remove(self, row_index_start_inclusive: int, row_index_stop_exclusive: int) -> None: ...

    # RowStatisticsMixin user methods
    def rows_count_missing_values(self) -> dict[int, int]: ...

    # RowAccessMixin user methods
    def row_get_as_dict(self, row_index: int, column_keys: list[CK]|None = None) -> dict[CK, SCALAR_TYPE]: ...
    def row_get_head(self, n: int = 5) -> list[dict[CK, SCALAR_TYPE]]: ...
    def row_get_tail(self, n: int = 5) -> list[dict[CK, SCALAR_TYPE]]: ...
    def row_get_first(self) -> dict[CK, SCALAR_TYPE]: ...
    def row_get_last(self) -> dict[CK, SCALAR_TYPE]: ...
    def row_get_by_slice(self, start: int, stop: int, step: int = 1) -> list[dict[CK, SCALAR_TYPE]]: ...

    # CellOperationsMixin user methods
    def cell_get_value(self, row_index: int, column_key: CK) -> SCALAR_TYPE: ...
    def cell_set_value(self, row_index: int, column_key: CK, value: SCALAR_TYPE) -> None: ...

    # MaskOperationsMixin user methods
    def mask_get_equal_to(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_not_equal_to(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_greater_than(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_less_than(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_greater_equal(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_less_equal(self, column_key: CK, value: Any) -> BoolArray: ...
    def mask_get_in_range(self, column_key: CK, min_value: Any, max_value: Any) -> BoolArray: ...
    def mask_get_complete_rows(self, *column_keys: CK) -> BoolArray: ...
    def mask_get_incomplete_rows(self, *column_keys: CK) -> BoolArray: ...
    def mask_apply_to_dataframe(self, mask: BoolArray) -> "UnitedDataframe[CK]": ...
    def mask_get_by_function(self, filter_func: Callable[[dict[CK, SCALAR_TYPE]], bool], column_keys: list[CK]|None = None) -> BoolArray: ...

    # IterMixin user methods
    def iter_columns(self) -> Iterator[ColumnAccessor[CK]]: ...
    def iter_rows(self) -> Iterator[RowAccessor[CK]]: ...
    def iter_units(self) -> Iterator[Unit|None]: ...
    def iter_dimensions(self) -> Iterator[Dimension|None]: ...
    def iter_coltypes(self) -> Iterator[ColumnType]: ...

    # ColumnAccessMixin user methods
    def column_items(self) -> Iterator[tuple[CK, ColumnAccessor[CK]]]: ...
    def row_items(self) -> Iterator[tuple[int, RowAccessor[CK]]]: ...
    def unit_items(self) -> Iterator[tuple[CK, Unit|None]]: ...
    def dimension_items(self) -> Iterator[tuple[CK, Dimension]]: ...
    def coltype_items(self) -> Iterator[tuple[CK, ColumnType]]: ...

    # FilterMixin user methods
    def filter_column_equals(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_not_equals(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_greater_than(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_less_than(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_greater_equal(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_less_equal(self, column_key: CK, value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_in_range(self, column_key: CK, min_value: Any, max_value: Any) -> "UnitedDataframe[CK]": ...
    def filter_column_get_complete_rows(self, *column_keys: CK) -> "UnitedDataframe[CK]": ...
    def filter_column_get_incomplete_rows(self, *column_keys: CK) -> "UnitedDataframe[CK]": ...

    # SerializationMixin user methods
    def to_json(self) -> dict[str, Any]: ...
    def to_csv(self, path: str|None = None) -> str|None: ...
    def to_hdf5(self, path_or_group: Union[Path, str, h5py.Group], key: str = "dataframe", **kwargs: Any) -> None: ...
    def to_pickle(self, path: str|None = None) -> None: ...
    @classmethod
    def from_hdf5(cls, path_or_group: Union[Path, str, h5py.Group], key: str = "dataframe", internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter = SimpleInternalDataFrameNameFormatter(), **kwargs: Any) -> "UnitedDataframe[CK]": ...
    @classmethod
    def from_json(cls, data: dict[str, Any], internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter = SimpleInternalDataFrameNameFormatter()) -> T: ...
    @classmethod
    def from_pickle(cls, path: str|None = None, **kwargs: Any) -> "UnitedDataframe[CK]": ...

    # ConstructorMixin user methods
    @classmethod
    def create_empty_dataframe(cls, column_keys: List[CK], column_types: Dict[CK, ColumnType], column_units_or_dimensions: Dict[CK, Union[Unit, Dimension, None]], internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter) -> "UnitedDataframe[CK]": ...
    @classmethod
    def create_dataframe_from_data(cls, arrays: Dict[CK, Union[ARRAY_TYPE, List[LOWLEVEL_TYPE]]], column_types: Dict[CK, ColumnType], column_units_or_dimensions: Dict[CK, Union[Unit, Dimension, None]], internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter) -> "UnitedDataframe[CK]": ...
    @classmethod
    def create_dataframe_from_pandas_with_correct_column_names(cls, pandas_dataframe: pd.DataFrame, internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter, deep_copy: bool) -> "UnitedDataframe[CK]": ...
    @classmethod
    def create_dataframe_from_pandas_with_incorrect_column_names(cls, pandas_dataframe: pd.DataFrame, column_key_mapping: dict[str, CK], column_types: Dict[CK, ColumnType], column_units_or_dimensions: Dict[CK, Union[Unit, Dimension, None]], internal_dataframe_column_name_formatter: InternalDataFrameColumnNameFormatter, deep_copy: bool) -> "UnitedDataframe[CK]": ...

    # GroupbyMixin user methods
    def groupby(self, by: Union[CK, List[CK]], sort: bool = True, dropna: bool = True) -> Groups[CK]: ...
    def crop_dataframe(self, column_keys: Sequence[CK]|None = None, row_indices: Sequence[int]|slice|None = None) -> "UnitedDataframe[CK]": ...

    # AccessorMixin user methods
    def __str__(self) -> str: ...

    ######### INITIALIZER #########

    def __init__(self) -> None: ...

    ######### HELPER PROPERTY #########

    @property
    def _self(self) -> T:
        """
        Helper property that provides typed access to self.
        
        Usage in mixins:
            def some_method(self):
                # Now you get full autocomplete and type checking!
                with self._self._rlock:
                    return len(self._self._internal_dataframe)
        """
        return self  # type: ignore
